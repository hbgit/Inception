#define BMC_CHECK(predicate,line)   if(!(predicate)){ printf("Invariant Violated in line: %d \n", line); assert(0); } 
/* Generated by Frama-C */
struct __anonstruct___mpz_struct_1 {
   int _mp_alloc ;
   int _mp_size ;
   unsigned long *_mp_d ;
};
typedef struct __anonstruct___mpz_struct_1 __mpz_struct;
typedef __mpz_struct ( __attribute__((__FC_BUILTIN__)) mpz_t)[1];
typedef unsigned int size_t;
typedef unsigned int ino_t;
typedef unsigned int gid_t;
typedef unsigned int uid_t;
typedef long time_t;
typedef unsigned int blkcnt_t;
typedef unsigned int blksize_t;
typedef unsigned int dev_t;
typedef unsigned int mode_t;
typedef unsigned int nlink_t;
typedef long off_t;
struct stat {
   dev_t st_dev ;
   ino_t st_ino ;
   mode_t st_mode ;
   nlink_t st_nlink ;
   uid_t st_uid ;
   gid_t st_gid ;
   dev_t st_rdev ;
   off_t st_size ;
   time_t st_atime ;
   time_t st_mtime ;
   time_t st_ctime ;
   blksize_t st_blksize ;
   blkcnt_t st_blocks ;
   char *__fc_real_data ;
   int __fc_real_data_max_size ;
};
struct __fc_FILE {
   unsigned int __fc_stdio_id ;
   unsigned int __fc_maxsz ;
   unsigned int __fc_writepos ;
   unsigned int __fc_readpos ;
   int __fc_is_a_socket ;
   int mode ;
   struct stat *__fc_inode ;
};
typedef struct __fc_FILE FILE;
/*@ requires predicate ≢ 0;
    assigns \nothing; */
extern  __attribute__((__FC_BUILTIN__)) void e_acsl_assert(int predicate,
                                                           char *kind,
                                                           char *fct,
                                                           char *pred_txt,
                                                           int line);

/*@
model __mpz_struct { ℤ n };
*/
int __fc_random_counter __attribute__((__unused__));
unsigned long const __fc_rand_max = (unsigned long)32767;
/*@ ghost extern int __fc_heap_status; */

/*@
axiomatic
  dynamic_allocation {
  predicate is_allocable{L}(size_t n) 
    reads __fc_heap_status;
  
  }
 */
/*@ ghost extern int __e_acsl_init; */

/*@ ghost extern int __e_acsl_internal_heap; */

extern size_t __memory_size;

/*@
predicate diffSize{L1, L2}(ℤ i) =
  \at(__memory_size,L1)-\at(__memory_size,L2) ≡ i;
 */
FILE __fc_fopen[2];
FILE const *_p__fc_fopen = (FILE const *)(__fc_fopen);
int buffer[10];
int range_updated = 10;
int handle_buffer(void);

/*@ requires range ≡ 0 ∨ \valid(vet+(0 .. range-1)); */
void check_range(int range, int *vet)
{
  int i;
  int var_a;
  var_a = 2;
  i = 0;
  while (i < 10) {
    /*@ assert i < range_updated; */
BMC_CHECK( i < range_updated, 13); 
    e_acsl_assert(i < range_updated,(char *)"Assertion",
                  (char *)"check_range",(char *)"i < range_updated",13);
    *(vet + i) = 1 * var_a;
    var_a = i * var_a + range;
    i ++;
  }
  if (range < 10) {
    range_updated = range;
    handle_buffer();
  }
  return;
}

/*@ requires range ≡ 0 ∨ \valid(vet+(0 .. range-1)); */
void __e_acsl_check_range(int range, int *vet)
{
  check_range(range,vet);
  return;
}

int handle_buffer(void)
{
  int __e_acsl_at_6;
  int __e_acsl_at_5;
  int __e_acsl_at_4;
  int __e_acsl_at_3;
  int __e_acsl_at_2;
  int __e_acsl_at;
  int __retres;
  int i;
  /*@ requires i ≡ buffer[i];
      requires (int *)buffer ≡ \null;
      requires ∀ int i; 0 ≤ i ∧ i ≤ 9 ⇒ buffer[i] ≡ 0;
  */
  {
    int __e_acsl_forall;
    int __e_acsl_i;
BMC_CHECK( i < 10, 27); 
    e_acsl_assert(i < 10,(char *)"RTE",(char *)"handle_buffer",
                  (char *)"index_bound: i < 10",27);
BMC_CHECK( 0 <= i, 27); 
    e_acsl_assert(0 <= i,(char *)"RTE",(char *)"handle_buffer",
                  (char *)"index_bound: 0 <= i",27);
BMC_CHECK( i == buffer[i], 27); 
    e_acsl_assert(i == buffer[i],(char *)"Precondition",
                  (char *)"handle_buffer",(char *)"i == buffer[i]",27);
BMC_CHECK( buffer == (void *)0, 28); 
    e_acsl_assert(buffer == (void *)0,(char *)"Precondition",
                  (char *)"handle_buffer",(char *)"(int *)buffer == \\null",
                  28);
    __e_acsl_forall = 1;
    __e_acsl_i = 0;
    while (1) {
BMC_CHECK( __e_acsl_i <= 9 , 29); 
      if (__e_acsl_i <= 9) ; else break;
BMC_CHECK( __e_acsl_i < 10, 29); 
      e_acsl_assert(__e_acsl_i < 10,(char *)"RTE",(char *)"handle_buffer",
                    (char *)"index_bound: __e_acsl_i < 10",29);
BMC_CHECK( 0 <= __e_acsl_i, 29); 
      e_acsl_assert(0 <= __e_acsl_i,(char *)"RTE",(char *)"handle_buffer",
                    (char *)"index_bound: 0 <= __e_acsl_i",29);
BMC_CHECK( buffer[__e_acsl_i] == 0 , 29); 
      if (buffer[__e_acsl_i] == 0) ;
      else {
        __e_acsl_forall = 0;
        goto e_acsl_end_loop1;
      }
      __e_acsl_i ++;
    }
    e_acsl_end_loop1: ;
    e_acsl_assert(__e_acsl_forall,(char *)"Precondition",
                  (char *)"handle_buffer",
                  (char *)"\\forall int i; 0 <= i && i <= 9 ==> buffer[i] == 0",
                  29);
    __e_acsl_at_6 = i;
BMC_CHECK( (long long)i - (long long)1 < (long long)10, 48); 
    e_acsl_assert((long long)i - (long long)1 < (long long)10,(char *)"RTE",
                  (char *)"handle_buffer",
                  (char *)"index_bound: (long long)((long long)i-(long long)1) < 10",
                  48);
BMC_CHECK( 0LL <= (long long)i - (long long)1, 48); 
    e_acsl_assert(0LL <= (long long)i - (long long)1,(char *)"RTE",
                  (char *)"handle_buffer",
                  (char *)"index_bound: 0 <= (long long)((long long)i-(long long)1)",
                  48);
    __e_acsl_at_5 = buffer[(long long)i - (long long)1];
    __e_acsl_at_4 = i;
    __e_acsl_at_3 = i;
    __e_acsl_at_2 = i;
    __e_acsl_at = i;
    i = 0;
  }
  {
    int __e_acsl_forall_2;
    int __e_acsl_k;
    int __e_acsl_forall_3;
    int __e_acsl_j;
    __e_acsl_forall_2 = 1;
    __e_acsl_k = 0;
    while (1) {
BMC_CHECK( __e_acsl_k <= 9 , 39); 
      if (__e_acsl_k <= 9) ; else break;
BMC_CHECK( __e_acsl_k < 10, 39); 
      e_acsl_assert(__e_acsl_k < 10,(char *)"RTE",(char *)"handle_buffer",
                    (char *)"index_bound: __e_acsl_k < 10",39);
BMC_CHECK( 0 <= __e_acsl_k, 39); 
      e_acsl_assert(0 <= __e_acsl_k,(char *)"RTE",(char *)"handle_buffer",
                    (char *)"index_bound: 0 <= __e_acsl_k",39);
BMC_CHECK( buffer[__e_acsl_k] != __e_acsl_at , 39); 
      if (buffer[__e_acsl_k] != __e_acsl_at) ;
      else {
        __e_acsl_forall_2 = 0;
        goto e_acsl_end_loop2;
      }
      __e_acsl_k ++;
    }
    e_acsl_end_loop2: ;
    e_acsl_assert(! __e_acsl_forall_2,(char *)"Invariant",
                  (char *)"handle_buffer",
                  (char *)"!(\\forall int k; 0 <= k && k <= 9 ==> buffer[k] != \\at(i,Pre))",
                  39);
    __e_acsl_forall_3 = 1;
    __e_acsl_j = 0;
    while (1) {
BMC_CHECK( __e_acsl_j <= 9 , 38); 
      if (__e_acsl_j <= 9) ; else break;
BMC_CHECK( __e_acsl_j < 10, 38); 
      e_acsl_assert(__e_acsl_j < 10,(char *)"RTE",(char *)"handle_buffer",
                    (char *)"index_bound: __e_acsl_j < 10",38);
BMC_CHECK( 0 <= __e_acsl_j, 38); 
      e_acsl_assert(0 <= __e_acsl_j,(char *)"RTE",(char *)"handle_buffer",
                    (char *)"index_bound: 0 <= __e_acsl_j",38);
BMC_CHECK( buffer[__e_acsl_j] == i , 38); 
      if (buffer[__e_acsl_j] == i) ;
      else {
        __e_acsl_forall_3 = 0;
        goto e_acsl_end_loop3;
      }
      __e_acsl_j ++;
    }
    e_acsl_end_loop3: ;
    e_acsl_assert(__e_acsl_forall_3,(char *)"Invariant",
                  (char *)"handle_buffer",
                  (char *)"\\forall int j; 0 <= j && j <= 9 ==> buffer[j] == i",
                  38);
    /*@ loop invariant ∀ int j; 0 ≤ j ∧ j ≤ 9 ⇒ buffer[j] ≡ i;
        loop invariant
          ¬(∀ int k; 0 ≤ k ∧ k ≤ 9 ⇒ buffer[k] ≢ \at(i,Pre));
    */
    while (i <= range_updated) {
      buffer[i] = i;
      {
        int __e_acsl_forall_4;
        int __e_acsl_j_2;
        int __e_acsl_forall_5;
        int __e_acsl_k_2;
        i ++;
        __e_acsl_forall_4 = 1;
        __e_acsl_j_2 = 0;
        while (1) {
BMC_CHECK( __e_acsl_j_2 <= 9 , 38); 
          if (__e_acsl_j_2 <= 9) ; else break;
BMC_CHECK( __e_acsl_j_2 < 10, 38); 
          e_acsl_assert(__e_acsl_j_2 < 10,(char *)"RTE",
                        (char *)"handle_buffer",
                        (char *)"index_bound: __e_acsl_j_2 < 10",38);
BMC_CHECK( 0 <= __e_acsl_j_2, 38); 
          e_acsl_assert(0 <= __e_acsl_j_2,(char *)"RTE",
                        (char *)"handle_buffer",
                        (char *)"index_bound: 0 <= __e_acsl_j_2",38);
BMC_CHECK( buffer[__e_acsl_j_2] == i , 38); 
          if (buffer[__e_acsl_j_2] == i) ;
          else {
            __e_acsl_forall_4 = 0;
            goto e_acsl_end_loop4;
          }
          __e_acsl_j_2 ++;
        }
        e_acsl_end_loop4: ;
        e_acsl_assert(__e_acsl_forall_4,(char *)"Invariant",
                      (char *)"handle_buffer",
                      (char *)"\\forall int j; 0 <= j && j <= 9 ==> buffer[j] == i",
                      38);
        __e_acsl_forall_5 = 1;
        __e_acsl_k_2 = 0;
        while (1) {
BMC_CHECK( __e_acsl_k_2 <= 9 , 39); 
          if (__e_acsl_k_2 <= 9) ; else break;
BMC_CHECK( __e_acsl_k_2 < 10, 39); 
          e_acsl_assert(__e_acsl_k_2 < 10,(char *)"RTE",
                        (char *)"handle_buffer",
                        (char *)"index_bound: __e_acsl_k_2 < 10",39);
BMC_CHECK( 0 <= __e_acsl_k_2, 39); 
          e_acsl_assert(0 <= __e_acsl_k_2,(char *)"RTE",
                        (char *)"handle_buffer",
                        (char *)"index_bound: 0 <= __e_acsl_k_2",39);
BMC_CHECK( buffer[__e_acsl_k_2] != __e_acsl_at_2 , 39); 
          if (buffer[__e_acsl_k_2] != __e_acsl_at_2) ;
          else {
            __e_acsl_forall_5 = 0;
            goto e_acsl_end_loop5;
          }
          __e_acsl_k_2 ++;
        }
        e_acsl_end_loop5: ;
        e_acsl_assert(! __e_acsl_forall_5,(char *)"Invariant",
                      (char *)"handle_buffer",
                      (char *)"!(\\forall int k; 0 <= k && k <= 9 ==> buffer[k] != \\at(i,Pre))",
                      39);
      }
    }
  }
  /*@ assert i ≡ 9; */
BMC_CHECK( i == 9, 46); 
  e_acsl_assert(i == 9,(char *)"Assertion",(char *)"handle_buffer",
                (char *)"i == 9",46);
  /*@ assert \at(i,Pre) ≡ buffer[\at(i,Pre)]; */
BMC_CHECK( __e_acsl_at_4 < 10, 0); 
  e_acsl_assert(__e_acsl_at_4 < 10,(char *)"RTE",(char *)"handle_buffer",
                (char *)"index_bound: __e_acsl_at_4 < 10",0);
BMC_CHECK( 0 <= __e_acsl_at_4, 0); 
  e_acsl_assert(0 <= __e_acsl_at_4,(char *)"RTE",(char *)"handle_buffer",
                (char *)"index_bound: 0 <= __e_acsl_at_4",0);
BMC_CHECK( __e_acsl_at_3 == buffer[__e_acsl_at_4], 47); 
  e_acsl_assert(__e_acsl_at_3 == buffer[__e_acsl_at_4],(char *)"Assertion",
                (char *)"handle_buffer",
                (char *)"\\at(i,Pre) == buffer[\\at(i,Pre)]",47);
  /*@ assert \at(buffer[\at(i,Here)-1],Pre) ≡ buffer[\at(i,Pre)]; */
BMC_CHECK( __e_acsl_at_6 < 10, 0); 
  e_acsl_assert(__e_acsl_at_6 < 10,(char *)"RTE",(char *)"handle_buffer",
                (char *)"index_bound: __e_acsl_at_6 < 10",0);
BMC_CHECK( 0 <= __e_acsl_at_6, 0); 
  e_acsl_assert(0 <= __e_acsl_at_6,(char *)"RTE",(char *)"handle_buffer",
                (char *)"index_bound: 0 <= __e_acsl_at_6",0);
BMC_CHECK( __e_acsl_at_5 == buffer[__e_acsl_at_6], 48); 
  e_acsl_assert(__e_acsl_at_5 == buffer[__e_acsl_at_6],(char *)"Assertion",
                (char *)"handle_buffer",
                (char *)"\\at(buffer[\\at(i,Here)-1],Pre) == buffer[\\at(i,Pre)]",
                48);
  /*@ assert \false; */
BMC_CHECK( 0, 51); 
  e_acsl_assert(0,(char *)"Assertion",(char *)"handle_buffer",
                (char *)"\\false",51);
  __retres = 0;
  return __retres;
}

int main(void)
{
  int __retres;
  range_updated = 10;
  __e_acsl_check_range(8,buffer);
  __retres = 1;
  return __retres;
}


